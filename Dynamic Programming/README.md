## DP

### Fibonacci style
* 相邻的数不能取，或者爬楼梯可以走一步或者走两部
* dp[i] 的值跟dp[i - 1] 和 dp[i - 2]有关
* 70, 509, 1137, 746, 198, 740

### Matrix
* 二维矩阵dp问题
* 一般是当前格子的值会跟它四个方向的值有关
* 62, 63, 64, 120, 931, 221

### On Strings
* 字符串相关，一般是判断字符串中包含多少个符合条件的子串
* 通常是二维dp memo, 以当前字符为准dp[i]，与剩余的字符i到j的值相关dp[i+1][j]
* 516, 139, 5, 72, 712, 115

### Longest Increasing Subsequence(LIS)
* 最长子序列问题

方法1
* 通常是两层循环，从末尾i开始遍历，从j(i+1)到末尾n，计算以i字符为起点时的LIS。
* if nums[i] < nums[j]: dp[i] = max(dp[i], dp[j] + 1), j为从i+1到n的遍历

方法2
* 用一个数组sub来存储LIS每个位置的边界值
* 当前数字为nums[i]时，根据它的值更新边界值，最后返回sub的长度即可（不知道我在表达什么，我也似懂非懂/(ㄒoㄒ)/~~）
* eg: nums = 7, 10, 6, 8, 9, 9, 3, 18
* i = 0 -> 7
* i = 1, 10 > 7 -> 7, 10
* i = 2, 距离6最近的大于等于它的值是7，更新边界值 ->  6, 10
* 依次类推...
* 300

题目
* 300, 673, 646
* 1218, 1027: 其实是相同方法，只是多了一个memo优化. 从头部i开始遍历，逐个比较0~i的值
* 354, 1964: 方法2

### Longest Common Subsequence
* if text1[i - 1] == text2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1
* else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
* 1143, 1035
* 5, 1312

### Best Time to Buy & Sell Stock / State Machine
* 多个状态
* 列举出所有状态，分析各个状态之间的关系，构建dp公式
* 309, 714