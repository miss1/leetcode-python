## DP

### Fibonacci style
* 相邻的数不能取，或者爬楼梯可以走一步或者走两部
* dp[i] 的值跟dp[i - 1] 和 dp[i - 2]有关
* 70, 509, 1137, 746, 198, 740

### Matrix
* 二维矩阵dp问题
* 一般是当前格子的值会跟它四个方向的值有关
* 62, 63, 64, 120, 931, 221

### On Strings
* 字符串相关，一般是判断字符串中包含多少个符合条件的子串
* 通常是二维dp memo, 以当前字符为准dp[i]，与剩余的字符i到j的值相关dp[i+1][j]
* 516, 139, 5, 72, 712, 115

### Longest Increasing Subsequence(LIS)
* 最长子序列问题
* 通常是两层循环，从末尾i开始遍历，从j(i+1)到末尾n，计算以i字符为起点时的LIS。
* if nums[i] < nums[j]: dp[i] = max(dp[i], dp[j] + 1), j为从i+1到n的遍历
* 300, 673, 646
* 1218, 1027, 354: 其实是相同方法，只是多了一个memo优化. 从头部i开始遍历，逐个比较0~i的值